'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatNumber = formatNumber;
exports.shortenText = shortenText;

var _fp = require('lodash/fp');

var roundAt = _fp.round.convert({ fixed: false });

function formatNumber(number) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var opt = Object.assign({
    shorten: true,
    decimals: 0
  }, options);

  // First ensure that we actually have a number
  var n = Number(number);
  if (Number.isNaN(n)) {
    console.warn('formatNumber was called with a non-number:', n);
    return n;
  }

  // Shorten the number
  if (n >= 1000 && opt.shorten) {
    return ['k', 'M', 'B'].reduceRight(function (acc, key, index) {
      // When the accumulator is astring, we are done
      if (typeof acc === 'string') return acc;

      var target = Math.pow(1000, index + 1);

      // The number is too small for this key, move to alower one
      if (acc < target) return acc;

      // Nailed it
      var res = acc / target;
      return '' + roundAt(res, 1) + key;
    }, n);
  }

  var decimals = opt.decimals;

  // Deice the decimals based on the number when not specified
  if (!decimals && decimals !== 0) {
    if (n < 1) {
      decimals = 3;
    } else if (n < 10) {
      decimals = 1;
    } else {
      decimals = 0;
    }
  }

  // Format thousands
  return Math.max(0, n).toFixed(decimals).replace(/(?=(?:\d{3})+$)(?!^)/g, '.');
}

function shortenText(text, maxLength) {
  var trimmedText = text;

  if (trimmedText && trimmedText.length > maxLength) {
    trimmedText = trimmedText.substr(0, maxLength - 1) + '\u2026';
  }

  return trimmedText;
}