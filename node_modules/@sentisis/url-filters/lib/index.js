"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.encode = encode;
exports.decode = decode;

var _fp = require("lodash/fp");

var _fp2 = _interopRequireDefault(_fp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var fields = ["from", "to", "source", "view", "category", "theme", "feed", "author", "mentions", "sentiment", "gender", "location", "hashtag", "text", "aspect", "age", "maritalStatus", "interest", "device", "messageId", "mediaType", "mainMessage", "uncategorized", "product", "parentId", "occupation", "url", "followers", "isDark"];

var operators = ["or", "not", "and", "match"];

var sources = ["TWITTER", "FACEBOOK", "INSTAGRAM", "YOUTUBE", "MEDIA"];

var NUMBER = "NUMBER";
var BOOL = "BOOL";
var STRING = "STRING";
var SOURCE = "SOURCE";
var OPERATOR = "OPERATOR";
var RANGE = "RANGE";

// Get the type of the field
var getType = function getType(key) {
  switch (key) {
    case "from":
    case "to":
      return NUMBER;

    case "source":
      return SOURCE;

    case "mainMessage":
    case "uncategorized":
      return BOOL;

    case "view":
    case "product":
      return STRING;

    case "followers":
      return RANGE;

    default:
      return OPERATOR;
  }
};

var getTypeKey = function getTypeKey(type) {
  switch (type) {
    case NUMBER:
      return "n";

    case SOURCE:
      return "s";

    case BOOL:
      return "b";

    case STRING:
      return "m";

    case OPERATOR:
      return "o";

    case RANGE:
      return "r";

    default:
      throw new Error("Unknown type \"" + type + "\"");
  }
};

function encodeString(str) {
  if (typeof str === "string") return encodeURIComponent(str.replace("*", "*2A").replace("!", "*21"));
  return str;
}

var encodeOperator = _fp2.default.flow(_fp2.default.toPairs, _fp2.default.sortBy(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 1),
      key = _ref2[0];

  return operators.indexOf(key);
}), _fp2.default.flatMap(function (_ref3) {
  var _ref4 = _slicedToArray(_ref3, 2),
      key = _ref4[0],
      val = _ref4[1];

  if (!_fp2.default.isArray(val)) return [[key, val]];
  return _fp2.default.map(function (v) {
    return [key, v];
  }, val);
}), _fp2.default.map(function (_ref5) {
  var _ref6 = _slicedToArray(_ref5, 2),
      key = _ref6[0],
      val = _ref6[1];

  return "" + operators.indexOf(key) + encodeString(val);
}), _fp2.default.join("~"));

var encodeRange = _fp2.default.flow(_fp2.default.toPairs, _fp2.default.map(function (_ref7) {
  var _ref8 = _slicedToArray(_ref7, 2),
      key = _ref8[0],
      val = _ref8[1];

  var prefix = key === "min" ? "0" : "1";
  return "" + prefix + Number(val).toString(16);
}), _fp2.default.join("~"));

var encodeType = function encodeType(type, value) {
  switch (type) {
    case NUMBER:
      return value;

    case BOOL:
      return value ? 1 : 0;

    case STRING:
      return encodeString(value);

    case OPERATOR:
      return encodeOperator(value);

    case SOURCE:
      return sources.indexOf(value);

    case RANGE:
      return encodeRange(value);

    default:
      throw new Error("Unkown type");
  }
};

/**
 * Encode the passed filters as the url-string
 *
 * @param {Object} filters
 * @return {string}
 */
function encode(filters) {
  return _fp2.default.flow(_fp2.default.toPairs, _fp2.default.sortBy(function (_ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
        key = _ref10[0];

    return fields.indexOf(key);
  }), _fp2.default.reject(function (k) {
    return _fp2.default.isNil(k[1]);
  }), _fp2.default.map(function (_ref11) {
    var _ref12 = _slicedToArray(_ref11, 2),
        key = _ref12[0],
        val = _ref12[1];

    var type = getType(key);
    var typeKey = getTypeKey(type);
    var fieldIndex = fields.indexOf(key);

    if (fieldIndex < 0) {
      throw new Error("Field \"" + key + "\" is not supported in the URL filters.");
    }

    return "!" + fieldIndex + typeKey + encodeType(type, val);
  }), _fp2.default.join(""))(filters);
}

var fromTypeKey = function fromTypeKey(typeKey) {
  switch (typeKey) {
    case "n":
      return NUMBER;

    case "s":
      return SOURCE;

    case "b":
      return BOOL;

    case "m":
      return STRING;

    case "o":
      return OPERATOR;

    case "r":
      return RANGE;

    default:
      throw new Error("Unknown type key: " + typeKey);
  }
};

function decodeString(str) {
  if (typeof str === "string") return decodeURIComponent(str.replace("*2A", "*").replace("*21", "!"));
  return str;
}

var decodeOperator = _fp2.default.flow(_fp2.default.split("~"), _fp2.default.filter(Boolean), _fp2.default.map(function (val) {
  var _val$match = val.match(/([0-9]{1})(.+)/),
      _val$match2 = _slicedToArray(_val$match, 3),
      opIndex = _val$match2[1],
      opValue = _val$match2[2];

  return [operators[opIndex], decodeString(opValue)];
}), _fp2.default.groupBy(function (k) {
  return k[0];
}), _fp2.default.mapValues(_fp2.default.map(function (k) {
  return k[1];
})), function (op) {
  if (!op.match) return op;
  return _fp2.default.set("match", op.match[0], op);
});

var decodeRange = _fp2.default.flow(_fp2.default.split("~"), _fp2.default.reject(_fp2.default.isNil), _fp2.default.reduce(function (acc, val) {
  var _val$split = val.split(""),
      _val$split2 = _toArray(_val$split),
      type = _val$split2[0],
      value = _val$split2.slice(1);

  var key = type === "0" ? "min" : "max";

  return _extends({}, acc, _defineProperty({}, key, Number.parseInt(value.join(""), 16)));
}, {}));

var decodeValue = function decodeValue(type, value) {
  switch (type) {
    case NUMBER:
      return Number(value);

    case BOOL:
      return Number(value) === 1;

    case STRING:
      return decodeString(value);

    case OPERATOR:
      return decodeOperator(value);

    case SOURCE:
      return sources[Number(value)];

    case RANGE:
      return decodeRange(value);

    default:
      throw new Error("Unkown type");
  }
};

/**
 * Decode the passed filter string as the filters object
 *
 * @param {string} str
 * @return {Object} filters
 */
var decodeRegEx = /([0-9]*)([a-z])(.+)/;
function decode(str) {
  return _fp2.default.flow(
  // Remove the first !
  _fp2.default.trimCharsStart("!"), _fp2.default.split("!"), _fp2.default.reject(function (val) {
    return _fp2.default.isNil(val) || !decodeRegEx.test(val);
  }), _fp2.default.map(function (val) {
    var _val$match3 = val.match(decodeRegEx),
        _val$match4 = _slicedToArray(_val$match3, 4),
        keyIndex = _val$match4[1],
        typeKey = _val$match4[2],
        encodedVal = _val$match4[3];

    var type = fromTypeKey(typeKey);
    return [fields[keyIndex], decodeValue(type, encodedVal)];
  }), _fp2.default.fromPairs)(str);
}